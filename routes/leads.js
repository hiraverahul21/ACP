const express = require('express');
const { body, validationResult } = require('express-validator');
const { prisma } = require('../config/database');
const { AppError, asyncHandler } = require('../middleware/errorHandler');
const { authenticate, authorize, requirePermissionWithCompany } = require('../middleware/auth');
const { logger } = require('../utils/logger');

const router = express.Router();

// Apply authentication to all routes
router.use(authenticate);



// Validation rules
const createLeadValidation = [
  body('customer_name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Customer name must be between 2 and 100 characters'),
  
  body('customer_phone')
    .isMobilePhone('en-IN')
    .withMessage('Please provide a valid Indian mobile number'),
  
  body('customer_email')
    .optional()
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email address'),
  
  body('service_type')
    .isIn(['RESIDENTIAL_PEST_CONTROL', 'COMMERCIAL_PEST_CONTROL', 'TERMITE_CONTROL', 'RODENT_CONTROL', 'COCKROACH_CONTROL', 'ANT_CONTROL', 'MOSQUITO_CONTROL', 'BED_BUG_CONTROL', 'BIRD_CONTROL', 'SNAKE_CONTROL'])
    .withMessage('Invalid service type'),
  
  body('property_type')
    .isIn(['APARTMENT', 'INDEPENDENT_HOUSE', 'VILLA', 'OFFICE', 'SHOP', 'RESTAURANT', 'WAREHOUSE', 'FACTORY', 'HOSPITAL', 'SCHOOL', 'OTHER'])
    .withMessage('Invalid property type'),
  
  body('property_size')
    .optional()
    .isNumeric()
    .withMessage('Property size must be a number'),
  
  body('address')
    .trim()
    .isLength({ min: 10, max: 500 })
    .withMessage('Address must be between 10 and 500 characters'),
  
  body('city')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('City must be between 2 and 50 characters'),
  
  body('state')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('State must be between 2 and 50 characters'),
  
  body('pincode')
    .isLength({ min: 6, max: 6 })
    .isNumeric()
    .withMessage('Pincode must be a 6-digit number'),

  body('area')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Area must be between 2 and 100 characters'),

  body('lead_generated_by')
    .optional()
    .isLength({ min: 1 })
    .withMessage('Lead generated by must be a valid staff ID'),

  body('lead_type')
    .optional()
    .isIn(['ONCALL', 'AMC'])
    .withMessage('Lead type must be either ONCALL or AMC'),

  body('urgency_level')
    .optional()
    .isIn(['LOW', 'MEDIUM', 'HIGH', 'EMERGENCY'])
    .withMessage('Invalid urgency level'),
  
  body('preferred_date')
    .optional()
    .isISO8601()
    .withMessage('Please provide a valid date'),
  
  body('preferred_time')
    .optional()
    .matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .withMessage('Please provide time in HH:MM format'),
  
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description cannot exceed 1000 characters'),

  body('lead_services')
    .optional()
    .isArray({ min: 1 })
    .withMessage('Lead services must be an array with at least one service'),

  body('lead_services.*.service_type')
    .isIn(['RESIDENTIAL_PEST_CONTROL', 'COMMERCIAL_PEST_CONTROL', 'TERMITE_CONTROL', 'RODENT_CONTROL', 'COCKROACH_CONTROL', 'ANT_CONTROL', 'MOSQUITO_CONTROL', 'BED_BUG_CONTROL', 'BIRD_CONTROL', 'SNAKE_CONTROL'])
    .withMessage('Invalid service type in lead services'),

  body('lead_services.*.description')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Service description cannot exceed 500 characters'),

  body('lead_services.*.frequency')
    .optional()
    .isIn(['ONE_TIME', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'HALF_YEARLY', 'YEARLY'])
    .withMessage('Invalid frequency in lead services'),


];

const updateLeadValidation = [
  body('customer_name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Customer name must be between 2 and 100 characters'),
  
  body('customer_phone')
    .optional()
    .isMobilePhone('en-IN')
    .withMessage('Please provide a valid Indian mobile number'),
  
  body('customer_email')
    .optional()
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email address'),
  
  body('status')
    .optional()
    .isIn(['NEW', 'CONTACTED', 'QUOTED', 'CONFIRMED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'FOLLOW_UP'])
    .withMessage('Invalid status'),
  
  body('urgency_level')
    .optional()
    .isIn(['LOW', 'MEDIUM', 'HIGH', 'EMERGENCY'])
    .withMessage('Invalid urgency level'),

  body('lead_type')
    .optional()
    .isIn(['ONCALL', 'AMC'])
    .withMessage('Lead type must be either ONCALL or AMC'),

  body('preferred_date')
    .optional()
    .isISO8601()
    .withMessage('Please provide a valid date'),
  
  body('preferred_time')
    .optional()
    .matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .withMessage('Please provide time in HH:MM format'),

  body('notes')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Notes cannot exceed 1000 characters')
];

// Helper function to handle validation errors
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map(error => error.msg);
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errorMessages
    });
  }
  next();
};

// @route   GET /api/leads
// @desc    Get all leads with filtering and pagination
// @access  Private
router.get('/', asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    status,
    service_type,
    urgency_level,
    city,
    assigned_to,
    date_from,
    date_to,
    search,
    sortField = 'created_at',
    sortDirection = 'desc'
  } = req.query;

  const skip = (parseInt(page) - 1) * parseInt(limit);
  const take = parseInt(limit);

  // Validate sort field
  const allowedSortFields = ['customer_name', 'created_at', 'status', 'urgency_level', 'lead_type', 'city'];
  const validSortField = allowedSortFields.includes(sortField) ? sortField : 'created_at';
  const validSortDirection = ['asc', 'desc'].includes(sortDirection) ? sortDirection : 'desc';

  // Build where clause
  const where = {};

  if (status) where.status = status;
  if (service_type) where.service_type = service_type;
  if (urgency_level) where.urgency_level = urgency_level;
  if (city) where.city = { contains: city, mode: 'insensitive' };
  if (assigned_to) where.assigned_to = assigned_to;

  if (date_from || date_to) {
    where.created_at = {};
    if (date_from) where.created_at.gte = new Date(date_from);
    if (date_to) where.created_at.lte = new Date(date_to);
  }

  if (search) {
    where.OR = [
      { customer_name: { contains: search, mode: 'insensitive' } },
      { customer_phone: { contains: search } },
      { customer_email: { contains: search, mode: 'insensitive' } },
      { address: { contains: search, mode: 'insensitive' } }
    ];
  }

  // Role-based filtering
  if (req.user.role === 'TECHNICIAN') {
    where.assigned_to = req.user.id;
  } else if (req.user.role === 'AREA_MANAGER' && req.user.branch_id) {
    // Area managers can only see leads from their branch
    where.branch_id = req.user.branch_id;
  } else if (req.user.role === 'ADMIN' && req.user.company_id) {
    // Admin users can only see leads from their company
    where.company_id = req.user.company_id;
  }

  const [leads, total] = await Promise.all([
    prisma.lead.findMany({
      where,
      skip,
      take,
      orderBy: { [validSortField]: validSortDirection },
      include: {
        assigned_staff: {
          select: {
            id: true,
            name: true,
            role: true
          }
        },
        branch: {
          select: {
            id: true,
            name: true,
            city: true
          }
        },
        services: {
          select: {
            id: true,
            status: true,
            service_date: true
          }
        },
        lead_services: true
      }
    }),
    prisma.lead.count({ where })
  ]);

  const totalPages = Math.ceil(total / take);

  res.status(200).json({
    success: true,
    data: leads,
    pagination: {
      currentPage: parseInt(page),
      totalPages,
      totalRecords: total,
      hasNext: parseInt(page) < totalPages,
      hasPrev: parseInt(page) > 1
    }
  });
}));

// @route   GET /api/leads/staff
// @desc    Get staff members for lead generation dropdown
// @access  Private
router.get('/staff', asyncHandler(async (req, res) => {
  // Get staff from the same company as the current user
  const currentUser = await prisma.staff.findUnique({
    where: { id: req.user.id },
    select: { company_id: true }
  });

  if (!currentUser || !currentUser.company_id) {
    return res.status(400).json({
      success: false,
      message: 'User company not found'
    });
  }

  const staff = await prisma.staff.findMany({
    where: {
      company_id: currentUser.company_id,
      is_active: true
    },
    select: {
      id: true,
      name: true,
      role: true,
      email: true
    },
    orderBy: {
      name: 'asc'
    }
  });

  res.status(200).json({
    success: true,
    data: staff
  });
}));

// @route   GET /api/leads/:id
// @desc    Get single lead by ID
// @access  Private
router.get('/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;

  const lead = await prisma.lead.findUnique({
    where: { id },
    include: {
      assigned_staff: {
        select: {
          id: true,
          name: true,
          role: true,
          mobile: true,
          email: true
        }
      },
      branch: {
        select: {
          id: true,
          name: true,
          city: true,
          state: true,
          address: true,
          phone: true
        }
      },
      services: {
        include: {
          technician: {
            select: {
              id: true,
              name: true,
              mobile: true
            }
          }
        }
      },
      lead_services: true
    }
  });

  if (!lead) {
    return res.status(404).json({
      success: false,
      message: 'Lead not found'
    });
  }

  // Check access permissions
  if (req.user.role === 'TECHNICIAN' && lead.assigned_to !== req.user.id) {
    return res.status(403).json({
      success: false,
      message: 'Access denied'
    });
  }

  if (req.user.role === 'AREA_MANAGER' && lead.branch_id !== req.user.branch_id) {
    return res.status(403).json({
      success: false,
      message: 'Access denied'
    });
  }

  if (req.user.role === 'ADMIN' && lead.company_id !== req.user.company_id) {
    return res.status(403).json({
      success: false,
      message: 'Access denied'
    });
  }

  res.status(200).json({
    success: true,
    data: lead
  });
}));

// @route   POST /api/leads
// @desc    Create new lead
// @access  Private (Admin, Regional Manager, Area Manager)
router.post('/', authorize('ADMIN', 'REGIONAL_MANAGER', 'AREA_MANAGER', 'TECHNICIAN'), createLeadValidation, handleValidationErrors, asyncHandler(async (req, res) => {
  const {
    customer_name,
    customer_phone,
    customer_email,
    service_type,
    property_type,
    property_size,
    address,
    city,
    state,
    pincode,
    area,
    urgency_level = 'MEDIUM',
    preferred_date,
    preferred_time,
    description,
    branch_id,
    lead_generated_by,
    lead_services
  } = req.body;

  // Determine branch_id based on user role
  let finalBranchId = branch_id;
  if (req.user.role === 'AREA_MANAGER') {
    finalBranchId = req.user.branch_id; // Area managers can only create leads for their branch
  }

  // Validate branch if provided and get company_id
  let companyId = null;
  if (finalBranchId) {
    const branch = await prisma.branch.findUnique({
      where: { id: finalBranchId, is_active: true },
      select: {
        id: true,
        company_id: true
      }
    });

    if (!branch) {
      return res.status(400).json({
        success: false,
        message: 'Invalid branch selected'
      });
    }
    companyId = branch.company_id;
  } else {
    // If no branch specified, get user's company
    const userBranch = await prisma.staff.findUnique({
      where: { id: req.user.id },
      include: {
        branch: {
          select: {
            company_id: true
          }
        }
      }
    });
    if (userBranch && userBranch.branch) {
      companyId = userBranch.branch.company_id;
    }
  }

  const lead = await prisma.lead.create({
    data: {
      customer_name,
      customer_phone,
      customer_email,
      service_type,
      property_type,
      property_size: property_size ? parseFloat(property_size) : null,
      address,
      city,
      state,
      pincode,
      area,
      urgency_level,
      preferred_date: preferred_date ? new Date(preferred_date) : null,
      preferred_time,
      description,
      branch_id: finalBranchId,
      company_id: companyId,
      lead_generated_by,
      status: 'NEW',
      lead_services: lead_services && lead_services.length > 0 ? {
        create: lead_services.map(service => ({
          service_type: service.service_type,
          description: service.description || null,
          estimated_cost: service.estimated_cost ? parseFloat(service.estimated_cost) : null
        }))
      } : undefined
    },
    include: {
      branch: {
        select: {
          id: true,
          name: true,
          city: true
        }
      },
      lead_services: true
    }
  });

  logger.info(`New lead created: ${lead.id} by user: ${req.user.email}`);

  res.status(201).json({
    success: true,
    message: 'Lead created successfully',
    data: lead
  });
}));

// @route   PUT /api/leads/:id
// @desc    Update lead
// @access  Private
router.put('/:id', updateLeadValidation, handleValidationErrors, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;

  // Check if lead exists
  const existingLead = await prisma.lead.findUnique({
    where: { id }
  });

  if (!existingLead) {
    return res.status(404).json({
      success: false,
      message: 'Lead not found'
    });
  }

  // Check access permissions
  if (req.user.role === 'TECHNICIAN' && existingLead.assigned_to !== req.user.id) {
    return res.status(403).json({
      success: false,
      message: 'Access denied'
    });
  }

  if (req.user.role === 'AREA_MANAGER' && existingLead.branch_id !== req.user.branch_id) {
    return res.status(403).json({
      success: false,
      message: 'Access denied'
    });
  }

  // Extract lead_services from updateData if present
  const { lead_services, ...leadData } = updateData;

  // Remove undefined values and empty strings first
  Object.keys(leadData).forEach(key => {
    if (leadData[key] === undefined || leadData[key] === '') {
      delete leadData[key];
    }
  });

  // Handle date conversion for preferred_date after cleaning
  if (leadData.preferred_date) {
    leadData.preferred_date = new Date(leadData.preferred_date);
  }

  // Prepare update data with proper lead_services handling
  const updatePayload = {
    ...leadData,
    updated_at: new Date()
  };

  // Handle lead_services update if provided
  if (lead_services && Array.isArray(lead_services)) {
    updatePayload.lead_services = {
      deleteMany: {}, // Delete existing services
      create: lead_services.map(service => ({
        service_type: service.service_type,
        description: service.description,
        estimated_cost: service.estimated_cost
      }))
    };
  }

  const updatedLead = await prisma.lead.update({
    where: { id },
    data: updatePayload,
    include: {
      assigned_staff: {
        select: {
          id: true,
          name: true,
          role: true
        }
      },
      branch: {
        select: {
          id: true,
          name: true,
          city: true
        }
      },
      lead_services: true
    }
  });

  logger.info(`Lead updated: ${id} by user: ${req.user.email}`);

  res.status(200).json({
    success: true,
    message: 'Lead updated successfully',
    data: updatedLead
  });
}));

// @route   DELETE /api/leads/:id
// @desc    Delete lead
// @access  Private (Admin, Regional Manager only)
router.delete('/:id', authorize('ADMIN', 'REGIONAL_MANAGER'), asyncHandler(async (req, res) => {
  const { id } = req.params;

  const lead = await prisma.lead.findUnique({
    where: { id }
  });

  if (!lead) {
    return res.status(404).json({
      success: false,
      message: 'Lead not found'
    });
  }

  await prisma.lead.delete({
    where: { id }
  });

  logger.info(`Lead deleted: ${id} by user: ${req.user.email}`);

  res.status(200).json({
    success: true,
    message: 'Lead deleted successfully'
  });
}));

// @route   POST /api/leads/:id/assign
// @desc    Assign lead to staff member
// @access  Private (Admin, Regional Manager, Area Manager)
router.post('/:id/assign', authorize('ADMIN', 'REGIONAL_MANAGER', 'AREA_MANAGER', 'TECHNICIAN'), asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { staff_id } = req.body;

  if (!staff_id) {
    return res.status(400).json({
      success: false,
      message: 'Staff ID is required'
    });
  }

  // Check if lead exists
  const lead = await prisma.lead.findUnique({
    where: { id }
  });

  if (!lead) {
    return res.status(404).json({
      success: false,
      message: 'Lead not found'
    });
  }

  // Check if staff exists and is active
  const staff = await prisma.staff.findUnique({
    where: { id: staff_id, is_active: true }
  });

  if (!staff) {
    return res.status(400).json({
      success: false,
      message: 'Invalid staff member selected'
    });
  }

  // Area managers can only assign leads from their branch to staff from their branch
  if (req.user.role === 'AREA_MANAGER') {
    if (lead.branch_id !== req.user.branch_id || staff.branch_id !== req.user.branch_id) {
      return res.status(403).json({
        success: false,
        message: 'Access denied'
      });
    }
  }

  const updatedLead = await prisma.lead.update({
    where: { id },
    data: {
      assigned_to: staff_id,
      status: 'CONTACTED',
      updated_at: new Date()
    },
    include: {
      assigned_staff: {
        select: {
          id: true,
          name: true,
          role: true,
          mobile: true,
          email: true
        }
      }
    }
  });

  logger.info(`Lead ${id} assigned to ${staff.name} by user: ${req.user.email}`);

  res.status(200).json({
    success: true,
    message: 'Lead assigned successfully',
    data: updatedLead
  });
}));

// @route   GET /api/leads/stats/dashboard
// @desc    Get dashboard statistics
// @access  Private
router.get('/stats/dashboard', asyncHandler(async (req, res) => {
  const { date_from, date_to } = req.query;

  // Build date filter
  const dateFilter = {};
  if (date_from || date_to) {
    dateFilter.created_at = {};
    if (date_from) dateFilter.created_at.gte = new Date(date_from);
    if (date_to) dateFilter.created_at.lte = new Date(date_to);
  }

  // Role-based filtering
  const baseFilter = { ...dateFilter };
  if (req.user.role === 'TECHNICIAN') {
    baseFilter.assigned_to = req.user.id;
  } else if (req.user.role === 'AREA_MANAGER' && req.user.branch_id) {
    baseFilter.branch_id = req.user.branch_id;
  } else if (req.user.role === 'ADMIN' && req.user.company_id) {
    baseFilter.company_id = req.user.company_id;
  }

  const [statusStats, serviceTypeStats, urgencyStats, totalLeads, completedLeads] = await Promise.all([
    prisma.lead.groupBy({
      by: ['status'],
      where: baseFilter,
      _count: { status: true }
    }),
    prisma.lead.groupBy({
      by: ['service_type'],
      where: baseFilter,
      _count: { service_type: true }
    }),
    prisma.lead.groupBy({
      by: ['urgency_level'],
      where: baseFilter,
      _count: { urgency_level: true }
    }),
    prisma.lead.count({ where: baseFilter }),
    prisma.lead.count({ where: { ...baseFilter, status: 'COMPLETED' } })
  ]);

  const stats = {
    totalLeads,
    completedLeads,
    completionRate: totalLeads > 0 ? ((completedLeads / totalLeads) * 100).toFixed(2) : 0,
    statusBreakdown: statusStats.reduce((acc, item) => {
      acc[item.status] = item._count.status;
      return acc;
    }, {}),
    serviceTypeBreakdown: serviceTypeStats.reduce((acc, item) => {
      acc[item.service_type] = item._count.service_type;
      return acc;
    }, {}),
    urgencyBreakdown: urgencyStats.reduce((acc, item) => {
      acc[item.urgency_level] = item._count.urgency_level;
      return acc;
    }, {})
  };

  res.status(200).json({
    success: true,
    data: stats
  });
}));

module.exports = router;